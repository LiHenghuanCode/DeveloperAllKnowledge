## 1.进程和线程的区别是什么
**从基本概念上**
Operating System Concepts是这样说
进程是资源分配的基本单位，线程是CPU 调度的基本单位。

进程相当于一个容器，线程只是里面的一个东西。并且程序的本质是线程在运行。从内存结构的角度出发，进程的内存结构包括代码段，数据段，堆栈等，统称为 PCB。而线程之间共享同一进程的代码段和数据段资源，但也有自己的栈空间等等，这些统称为 TCB；从包含关系出发，一个进程至少存在一个线程，也可以拥有多个线程，但一个线程只属于一个进程。

在 Linux 里，线程和进程都统一抽象为 task_struct。调度器不关心你是进程还是线程，它调度的就是“一个可执行任务单元”。
在 Windows 里，线程 (ETHREAD) 是明确的调度单位，进程 (EPROCESS) 只是一个资源容器。

**从实际使用讲**
线程能减少并发执行的时间和空间开销
这是因为线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（**虚拟内存共享**），这意味着同一个进程的线程都具有同一个**页表**，那么在**切换**的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

### 1.1怎么理解线程是CPU 调度的基本单位？
线程是 CPU 调度的基本单位，但这个说法要结合历史来看：
早期没有线程概念时，调度的确是以进程为单位。
现代操作系统里，调度器调度的是线程（轻量级进程），进程只作为资源分配和隔离的容器。
所以有些教材里会说“进程是调度单位”，其实是历史遗留的说法；更准确的表述应该是：
进程是资源分配的基本单位，线程是调度的基本单位。

我们通常说线程是 CPU 调度的基本单位，意思是操作系统调度器分配 CPU 时间片的时候，调度的对象是线程，而不是进程。
进程更多像是一个资源容器，里面可以有多个线程。无论进程里有多少线程，最终都是这些线程排队等待 CPU 时间片，被操作系统的调度算法（比如时间片轮转、优先级调度、多级反馈队列等）选中，然后在 CPU 上运行。
所以，从 CPU 的角度，它根本不关心你属于哪个进程，只关心“下一个要执行的线程是谁”。

### 1.2刚才说到了线程切换保存上下文，那你觉得上下文都有哪些内容需要保持呢？
由于线程是由进程创建的，同一个进程下的所有线程共享进程的代码段和数据段等资源，除此之外，线程还有自己的栈空间，以及自己的线程存储空间。

所以当线程切换时，只需要保存线程私有的栈空间以及私有数据等等。

### 1.3进程里面有哪些内容？简单说一些
在操作系统中，使用进程控制块，也就是 PCB 来描述进程的。PCB 中主要包含进程描述信息，如进程标识符和用户标识符，前者用于唯一标识一个进程，后者用于标识进程所归属的用户；还有进程控制和管理信息，包括进程当前的状态和进程优先级等等；还有 CPU 相关信息，包括 CPU 中各个寄存器的值，当进程切换时，CPU 相关信息都保存在相应的 PCB 中，以便后续断点恢复。


## 2. 说一说进程间的通信方式有哪些？
首先第一个管道，管道在 Linux 中分为匿名管道和命名管道，Linux 命令中的 | ，> 等都是匿名管道，作用是将前一个命令的输出作为后一个命令的输入。命名管道可以用 mkfifo 命令创建，可以用在一个进程往里写，另一个进程从里读的场景。

管道的优点是使用简单，但只能用于有亲缘关系的进程间通信，且为单向通信。

然后是消息队列，这个消息队列不是中间件那些 MQ，它是保存在操作系统内核的消息链表，A 进程要给 B 进程发消息，只需将数据写入这个消息链表，B 进程需要时读取即可。

消息队列的优点是支持独立于进程的消息传递，缺点是传递的数据要在用户和内核空间来回复制，效率低，同时数据大小受操作系统限制。

共享内存的出现解决了消息队列中的数据要在用户和内核空间复制的问题，它是让所有进程的某块虚拟地址，都映射到一块相同的物理内存中。这样某个进程对这块地址的写入，其它进程都能立马看到。

这种方式是进程间通信速度最快的，但需要考虑共享资源的同步问题。

还有就是信号 signal，信号是进程通信中唯一的异步通信机制，任何时候都可以对某个进程发送某种信号，比如常见的 kill 命令，Cltr + C 发送终止信号，Cltr + Z 发送暂停信号等。

除了同一台主机上不同进程的通信，还可以使用 Socket 实现不同主机上进程间通信，期间需要建立连接，然后使用 write 和 read 来传递数据。

### 2.1那线程之间的通信方式又有哪些呢？

线程间的通信模型有两种：共享内存和消息传递

基于共享内存，可以使用 volatile，JUC 下的 CountDownLatch，ReentrantLock，LockSupport。基于消息传递，可以使用 Object 类提供的 wait，notify 方法。


## 3.说一下进程（任务）调度算法
常见的大约有六种：先来先服务，最短作业优先，高响应比优先，时间片轮转，最高优先级，多级反馈队列算法。
最新的算法有：

“首先先来先服务” 调度算法是最简单的。顾名思义，就是最先达到就绪队列的进程，优先运行。这对长作业有利，而短作业可能需要很长时间的等待时间。

“最短作业优先” 调度也是顾名思义，优先选择就绪队列中运行时间最短的运行。这对短作业有利，但对长作业不利，可能会造成多作业很多，长作业不断被延后的极端情况。

这两种算法都没有很好的权衡长短作业，而 “高响应比优先调度” 解决了这个问题，它给每个作业都定义了一个响应比：等待时间 + 要求服务时间➗要求服务时间，谁的响应比高就优先运行谁。当两个进程等待时间相等时，要求服务时间越小，响应比就越高，短作业就更容易运行；当两个进程要求服务时间相同，等待时间越长，响应比越高，这也兼顾了长作业进程。
还有就是使用最广，最公平的 “时间片轮转” 调度算法，它轮流为每个进程都分配一个时间片，进程只有获得时间片时才能运行，运行的时间取决于时间片的大小。如果时间片太大，会导致短作业的响应时间边长。如果时间片太小，又会带来过多的进程上下文切换，降低 CPU 效率。所以通常时间片设置为 20ms – 50ms 是一个合理的折中值。

由于 “时间片轮转” 算法是基于所有的进程同等重要，对于多用户计算机系统来说，它希望进程的调度具有优先级，每次从都从就绪队列中挑选出具有最高优先级的进行优先运行，这种算法叫做 “最高优先级” 调度算法。具体的优先级可以分为静态优先级和动态优先级。前者是指进程创建时就确定了优先级，后者是进程可以根据等待时间等等因素动态提高或降低优先级。

但 “时间片轮转” 也有缺点，比如低优先级的进程可能永远不会运行。而 “多级反馈队列” 调度算法综合了前面 “时间片轮转” 算法和 “最高优先级” 算法，它有多个就绪队列，每个队列代表的优先级从高到低，优先级越高时间片越短。它的工作流程为：新创建的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；这样的话，对于短作业来说，会在前几个锁分配时间片较小的队列就能优先完成。对于长作业来说，虽然经过的队列多，等待时间长，但同时分配的时间片也变长了。这个算法很好的兼顾了长短作业，同时也有较好的相应时间。


## 4.多线程会冲突吗
多线程会冲突，原因在于多个线程共享同一进程的内存空间。
如果多个线程同时读写同一份数据，就可能出现 数据竞争（race condition）。
冲突的结果可能是数据不一致、程序崩溃，甚至安全漏洞。
举个例子：两个线程同时对同一个全局变量 x 执行 x++ 操作。看似是一个简单的加一，但其实底层，我们以一个微架构设计是单循环的 CPU为例， x++操作分成三步骤：CPU 把内存/缓存行里的 x 读到寄存器、做ALU操作、把数据写回内存。如果两个线程交错执行，尤其是一个线程在当前CPU循环读入数据，而另一个线程的数据还没有到执行写回数据的哪个循环，就会导致出错，比如期望值是 2，结果却只加了一次。

### 4.1怎么避免
互斥锁（mutex）保证同一时刻只有一个线程修改数据。
读写锁（rwlock）区分读者和写者，提高并发度。
条件变量（condition variable）、信号量（semaphore）用来协调线程间顺序。
在无锁场景下，也可以使用 原子操作 或 内存屏障 来保证正确性。

### 4.2多线程效率一定比单线程要好吗？
这个需要看情况，如果是 CPU 密集型作业，在单核情况下，多线程的效率是不如单线程的。因为多线程会带来额外的线程上下文切换开销，单线程只需一直运行即可。

但如果是 IO 密集型作业，线程在进行 IO 操作时就不得不阻塞，此时 CPU 是闲着的，也就是 CPU 没有充分得到利用。此时就可以引入多线程，将任务拆分给多个线程去完成，当某个线程因进行 IO 而阻塞时，CPU 还可以处理其它线程任务，这个情况下多线程是比单线程效率高的。进一步，作业中 IO 操作的时间越长，多线程带来的效率提升就越高。
除了上边说的情况，还有就是如果作业量很小，使用多线程带来的线程创建开销和上下文切换开销是大于多线程本身的效率提高的。我做过一个实验，对两个变量进行累加和累减。并发情况将累加和累减交给两个线程完成，串行情况则在一个线程内完成两个操作，实验结果为在数据量在十万以下串行执行时间是小于并行的，数据量在百万以上并行的效率才与串行拉开差距。
### 4.3既然多线程或者单线程各有优劣势，那你可以举几个适合多线程或者单线程的例子吗？
在对视频或者图像进行处理，压缩时，由于每个像素可以独立处理，可以使用多线程来加快处理速度。还有对于高并发网络服务器而言，引入多线程可以同时处理多个客户端请求，能很大程度提高响应速度和吞吐量。

