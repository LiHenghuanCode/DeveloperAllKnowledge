
## 1. 二叉树的三序遍历
三序指前中后序，取决于根节点什么时候被遍历
前：根左右
中：左根右
后：左右根

### 1.1解法1——双重递归, 以中序遍历为例

递归函数重点在于：
1. 递归中止元素
2. 递归的下一元素
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        reverse(result,root);
        return result;

    }
    private void reverse(List<Integer> list,TreeNode root){
        if(root == null){
            return;
        }
        reverse(list,root.left);
        list.add(root.val);
        reverse(list,root.right);
    }
}
```
### 1.2 借助栈的迭代方法

### 1.3 Morris 遍历

## 2.二叉树的最大深度

遍历法，加使用max左右比较

```java
class Solution {
    public int maxDepth(TreeNode root) {
        
        if(root==null){
            return 0;
        }
        int i = 1+maxDepth(root.left);
        int j = 1+maxDepth(root.right);
        return (i>j)?i:j;
    }
    
}
```

## 3. 翻转二叉树
自己悟
注意check的中止检查
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root.left, root.right);
    }
    boolean check(TreeNode left,TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null || right == null){
            return false;
        }
        
        return (left.val == right.val) && check(left.left,right.right) && check(left.right,right.left);

    }
}
```

## 二叉树的直径
自己悟

## 二叉树的层序遍历
基于队列的广度优先搜索