## 1.应用层常见协议有哪些？
Web 访问相关的 HTTP/HTTPS、WebSocket；
域名与配置相关的 DNS、DHCP；
邮件协议 SMTP、POP3、IMAP；
文件与远程访问的 FTP、SSH、Telnet；
网络管理类的 SNMP、NTP；
此外，在后端开发中常用的 RPC 框架 gRPC、Dubbo 也属于应用层协议。

## 2. 什么是HTTP协议？
HTTP 协议全称为超文本传输协议，是一个应用层的协议，通常基于 TCP/IP 用于在网络的两点之间传输文字，视频等数据。他不是一个孤立的协议，需要下层很多其它协议的配合，最基本的就是 TCP/IP，实现可靠的数据传输，还有 DNS 协议实现域名到 IP 的查找

### 2.1 说说http请求报文包含什么？
基本上有三大部分组成：起始行，头部字段集合和消息正文。
1. 起始行描述了请求或响应的基本信息，
例如请求报文中的请求方法 GET 请求目标 / 和 版本号 HTTP/1.1；
响应报文中的版本号 HTTP/1.1，状态码 200 和状态码补充字段 OK。
2. 头部字段集合使用 key-value 的形式更详细的说明报文，可以自定义。比如常见的 Host 字段，用来指明这个请求该由哪个主机来处理；还有 User-Agent 字段，用来描述发起 HTTP 请求的客户端。
3. 消息正文就是实际传输的数据，比如IP文本或者图片，视频等二进制数据。

### 2.2Content-Length知道吗？如果Content-Length的长度 大于报文的实际长度，分析下会有什么问题？
Content-Length 用于指定报文中 Body 数据的字节长度。特别的，如果对数据本身就行了 gzip 压缩的话，Content-Length 指的是压缩后的长度。
对于接收放来说，Content-Length 的长度影响着对数据的截取，如果 Content-Length 的长度比实际的小，那么只会截取指定的一小部分，损失一部分信息，但大部分情况下页面还会正常显示。如果 Content-Length 比实际大，接收端在读到消息后会继续等待下一个字节，期间一直处于无响应状态，直到响应超时。此时页面是不能正常显示的。

### 2.3长链接和短连接介绍一下？
早期的 HTTP 0.9 和 1.0 就采用的短连接方式，每次发送 http 请求前都需要与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为短连接。
短连接的缺点很明显，对于客户端来说，每次请求都先需要三次握手建立连接，之后四次挥手关闭连接，当请求数增多的时候，效率就很低，严重的制约了服务器的服务能力，无法处理更多的请求。
之后根据短连接暴露出的缺点 HTTP 协议提出了长连接的通信方式，也叫连接保活 keep-alive。具体的工作方式是，对于相同客户端的多次请求，只需要在最开始时进行一次连接建立，和最后进行一次连接关闭，在这期间，客户端可以复用已经建立好的连接来发送其他请求，这样服务端的处理效率就高多了。
由于长连接对性能的改善效果十分显著，所以在 HTTP/1.1 中，默认就启用长连接。如果服务端支持长连接，会在响应报文中用 Connection : keep-alive 头部来表明。
不过长连接也有缺点，如果 TCP 连接长时间不关闭，服务器就必须在内存中保存它的状态，会占用大量的服务器资源。所以用了长连接，就需要考虑长连接在何时恰当的关闭。这有两种办法，在客户端中，可以在请求头中加上 Connection : close 字段，告诉服务器这次通信后就关闭连接。也可以在服务端的 Nginx 中通过 keepalive_time 来设置长连接的持续空闲时间。

### 2.4 要不HTTP1.0，1.1，2.0，3.0 区别也介绍一下？
HTTP 历史最早可以从 HTTP/0.9 说起，那时的 HTTP 非常简单，只能使用 GET 方法从服务器上获取 HTML 文档。之后由于多媒体等技术的发展，网络传输的数据不止局限于文本，还包括视频，音频等二进制流。HTTP/1.0 基于此，扩充了传输的数据范围，增加了 HEAD，POST 等新方法，引入了头部 Header 等等，形式上已经和我们现在的 HTTP 差别不大，但并没有广泛的运用。真正运用到实践中，并确立统治地位的是 HTTP/1.1，它相较于 1.0 又增加了 PUT，DELETE 等新方法，允许长连接，允许响应数据分块等等，一直沿用至今。
但由于互联网的发展速度太快，相比之下 HTTP/1.1 的连接速度越来越慢，Google 就在它的基础上推出了 SPDY 协议，并应用于 Chrome 中，倒逼 HTTP 进行改革。最终的 HTTP/2.0 就是以 SPDY 为基础，在性能方面做了比较大的提升，包括报文格式中用二进制取代 ASCII 码；使用专门的算法压缩头部，减少数据传输量；定义了虚拟的数据“流”的概念，并基于多路复用，避免了 HTTP 层面的队头阻塞问题。
再往后，由于 HTTP/2.0 只是解决了 HTTP 层面的队头阻塞，其下层的 TCP 还是会出现同样的队头阻塞问题，并且不论你 HTTP 层怎么变化，TCP 的这个问题一直存在。Google 于是决定抛弃 TCP，基于 UDP 优化出新的 QUIC 协议，并让 HTTP 跑在 QUIC 协议上，来彻底解决队头阻塞问题。HTTP/3.0 就是基于 QUIC 协议，应用了最新的 TLS 1.3，继承了 0-RTT 握手等特性，继续优化了性能。

### 2.5 http方法了解哪些？
目前 HTTP/1.1 规定了八种方法，包含常见的五种，比如用于获取资源的 GET 或 HEAD 方法，用于提交数据的 POST 或 PUT 方法，用于删除资源的 DELETE 方法。其他三种是用于建立特殊链接隧道的 CONNECT 方法，列出可对资源实行方法的 OPTIONS 方法，追踪请求到响应的传输路径的 TRACE 方法。
除了这些，我们还可以自定义方法类型，实际中用的多的有 LOCK 方法，用于暂时锁定某个资源不允许修改；还有 PATCH 方法用于给资源打个小布丁，更新部分数据等等。

### 2.6 get post 区别是什么？
GET 方法是从服务器那里获取数据，而 POST 方法是做相反的操作，向 URI 指定的资源提交数据，而数据就放在报文的 Body 里。
除此之外，两者的安全性和幂等性也不同，GET 方法对于服务器的资源是“只读”操作，不会破坏和修改服务器的资源，所以是安全的。同时无论 GET 操作多少次，在服务器上的数据是不会变的，所以 GET 也是幂等的。
而 POST 方法需要修改服务器上的资源，所以是不安全的。同时多次执行 POST 方法也就意味着多次提交数据，就会创建多个资源，所以不是幂等的。

### 2.7 http状态码有哪些（1xx-5xx），那讲一下301与302的区别？
HTTP 的状态码从 100 到 500 被分成了五类，1xx 表示提示信息，表示目前是协议处理的中间状态。2xx 表示成功，常见的就是 200。3xx 表示重定向，资源位置发生变动，需要客户端重新发送请求。4xx 表示客户端错误，代表请求报文有无，服务器无法处理，常见的是 403 和 404。5xx 是服务器错误，常见的 500 就是后端错误，503 表示服务器当前忙。

### 2.8 499和502了解吗？出现的原因是什么？
499 是 Nginx 自定义的一个状态码 client has closed connection，表示客户端连接已关闭。通常是因为服务端处理的时间过长，超过了客户端设置的 timeout 值。解决的话需要看后端服务是不是压力太大，或者调高接口的 timeout 值。
502 是 Bad Gateway，通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，但访问后端服务器时发生了错误。

### 2.9 Http TCP 都有保活 keep-alive 机制 两者有什么区别
HTTP 的 Keep-Alive 是由应用层实现的，称为 HTTP 长连接。TCP 的 Keepalive 是传输层实现的，称为 TCP 的保活机制。前者用于复用同一个 TCP 连接来进行多次的 HTTP 请求和应答，来减少 HTTP 多次短连接带来的 TCP 连接建立和释放的开销。后者则是在 TCP 连接双方长时间没有通信时，会由操作系统内核发送一个探测报文，来检测服务端是否仍然存活。如果连续多次探测报文无回应，客户端就会主动关闭连接。
简单来说，一个用于 TCP 心跳包检测，是为了提高可靠性的。一个是用来复用 TCP 连接，是为了提高性能的。

