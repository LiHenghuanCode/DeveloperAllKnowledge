## 1.介绍一下MySQL的索引
索引是一种帮助 MySQL 快速查找数据的数据结构。在没有索引时，如果我们要查找一条数据，只能采用全表扫描的方式，逐行判断，匹配到才返回给上层。
MySQL 中有很多引擎，不同引擎的索引实现不同，默认的引擎是 InnoDB。
InnoDB 中，索引的底层实现是 B+ 树。B+ 树的节点都是有序的，查找速度很快。而且 B+ 树的非叶子节点只存键值，叶子节点才会存储具体的数据，这样能减小整个树的大小，方便内存可以一次加载更多节点。除此之外，B+ 树的叶子节点间是用双向链表串联起来的，便于范围查找。范围查找也是 MySQL 中经常出现的操作。

### 1.1. 为什么索引要采用 B+ 树？用其他数据结构不可以吗？比如哈希表，B树，红黑树？
这首先的谈到 B+ 树的优点，首先它是一个 N 叉平衡树，也就是一个节点含有 N 个子节点，这样做可以降低树的高度，同时也可以让一个查询尽可能少的读磁盘，也就是减少了IO操作，IO操作相对来说是很慢的，减少了IO操作意味着总体的查询时间会变短。

除此之外，B+ 树的非叶子节点只存 key 不存 value，这样在相同的内存下，可以增多每次加载进内存的节点数量。还有 B+ 树的叶子节点之间使用双向链表相连，可以很好的支持常见的范围查询操作。

那么哈希表主要是用在 “等值查找” 的场景，能根据一个 key 在 O(1) 时间内返回它的 value。但是当我要做范围查找，我举个例子，我要返回一个产品集合中销量前五的五个产品，这个时候使用哈希表就必须进行全表扫描，其范围查找，尤其是需要对查找的有序序列时的效率甚至不如普通的双向链表。

有序数组在 “等值查找” 和 “范围查找” 的查询场景中性能很优秀，可以按照某个字段值递增，来构建一个有序数组，那么查询时用二分法就可以快速得到。不过缺点是有序数组在更新数据的时候效率很低，插入或删除某个数据时，都必须依次移动后面的所有记录。

二叉搜索树的话，它的查找更新性能都不错，都是 O(logN)，但是有一个问题，就是节点非常多的情况下，树的高度相较于 B+ 树也会非常高。一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。对于 B+ 树，当底层的 N 叉树 n = 1200 时，10 亿级的数据查询某个整数字段最多也只需查询 3 个数据块，相应的磁盘 IO 也就少的多了。

### 1.2介绍一下B+树是怎么分裂的？
B+ 树分裂时是从叶子节点开始的，接着是其父节点，一层一层的往上分裂，直到每个节点的子节点数不超过 B+ 树的阶数为止。

其中每个结点在分裂时，都是选取节点的中间大小元素，将这个元素向上移至父节点，然后检查父节点所在的节点数是否超过 B+ 树的阶数，不超过则结束，超过则继续重复这个过程。

### 1.3刚才说到了 B 树，B 树和 B+ 树的主要区别是什么？可以讲一讲 B 树的应用场景吗？
一个是 B+ 树的所有数据只存在于叶子节点中，而 B 树中的每个节点都存有数据。另一个是 B+ 树的叶子节点是通过双向链表相连，便于范围查询，B 树没有。

B 树的主要优点是优化了磁盘访问和减少磁盘 I/O 次数，大多数时候用在文件系统中，比如在 Windows NTFS 文件系统中，每个目录都对应着一个 B 树节点，可以快速地对文件进行查找和访问，提高文件系统性能。

## 2.看你很了解MySQL的索引，你是否在自己的项目中用过呢？你觉得什么样的字段适合加索引？
对于是否需要给字段加索引，需要考虑几个因素。第一个是要考虑索引的区分度，尽量选择区分度高的字段作为索引。第二个是需要考虑这个字段的查询频率。对于频繁增删改的字段，可以创建索引来加快查询速度。第三个是要考虑字段的长度，过长会占用空间，过短可能会导致索引区分度降低。比如身份证号只取前 6 位这种情况。

### 2.1 mysql怎么创建索引？

对于普通索引和联合索引，都是 CREATE INDEX 索引名 ON 表名(列名, ...) 。

对于唯一索引，多了一个 UNIQUE 关键字，CREATE UNIQUE INDEX。

如果想删除索引的话，是 DROP INDEX 索引名 ON 表名

### 2.2那你觉得，字段加了索引，查找的时候一定会走索引吗？（PS：可以回答索引失效的几个经典因素）

在 MySQL 中，字段加了索引 ≠ 查询一定会走索引。  
MySQL 是否使用索引，是由 优化器（Optimizer） 通过代价估算（Cost-based Optimization） 决定的。  
如果优化器判断「使用索引的代价 > 全表扫描的代价」，它就会放弃索引。

其藏在后面的逻辑是它会根据扫描行数、排序开销、是否需要临时表等代价模型来选择执行计划。

这些指标主要是考虑一些常见的索引问题，索引过滤性太低（匹配行太多），需要频繁回表（额外的随机 I/O）。统计信息估算不准，查询语句本身写法不当（如函数、模糊匹配）。
举个例子，使用函数或表达式会导致索引失效，因为函数破坏索引值的有序性，LIKE 前缀是通配符，这会导致无法定位起点
未遵守最左匹配原则。

对于只是扫描行数估计值不准确的情况，可以使用**analyze table** 语句重新统计索引信息，就可以解决。其它情况就需要考虑别的办法，让系统走我们认为对的索引，比如使用 **force index** 强行选择一个索引，或者根据实际情况新建一个更合适的索引，删除走错的索引等等。

### 2.3刚才说到了模糊匹配失效，为什么使用模糊匹配会失效，你能给我解释一下底层原理吗？
这种情况一般发生在使用 LIKE 关键字时，将通配符 % 放在了开头，导致索引用不上，只能进行全表扫描，效率很低。

原理是 InnoDB 索引底层是 B+ 树，对于字符串类型来说，每个叶子节点的数据都按照字符串的首字母排序，如果首字母相同，再比较第二个字母，以此类推。我们再进行模糊查询的时候，如果把 % 放在开头，会导致最左的 N 个字母是不确定的，无法根据索引的有序性定位到某个索引，只能进行全表扫描。

## 3.介绍一下索引的分类，以及他们的主要区别是什么？
### 3.1介绍一下索引的分类，以及他们的主要区别是什么？

在 InnoDB 中，按叶子节点存储的是否为完整的表数据，可以分为聚簇索引和二级索引。聚簇索引的每个叶子节点都存储了一行完整的数据，而二级索引的叶子节点只存储了某一列的数据和主键值，一般在利用二级索引进行查询时需要根据主键值进行回表操作，当然可以利用覆盖索引优化。

按字段进行分类，可分为主键索引，普通索引和前缀索引。主键索引是建立在主键上的索引，通常在创建表时一起创建。唯一索引不允许有重复值，但可以有多个空值。前缀索引是指对字符串类型字段的前几个字符，或者二进制类型的前几个字节建立的索引，合适的前缀索引既可以大幅减少索引占用的空间，又能提升索引的查询效率。

按索引字段个数分类，可分为单列索引和联合索引，区别在于建立索引的列数不同。

### 3.2介绍一下什么是复合索引？什么样的情况下我们会使用复合索引？

复合索引就是建立在多个列上的索引，多个列之间从左到右按次序排序，查询时也需要遵循 “最左匹配原则” 。

实践中一般在查询语句经常涉及到多个列作为查询条件时，可以创建一个联合索引加快查询速度。还可以在普通索引的基础上创建一个复合索引，将其优化为覆盖索引，省去用普通索引查询时的回表操作。除此之外，当语句需要根据某个字段排序或分组时，复合索引也能加快速度。

### 3.3唯一索引了解吗？在使用的时候，有什么需要注意的不？

唯一索引需要确保索引列中的所有值都是唯一的，但不保证值为 NULL，也就是可以插入多个 NULL 值。实践中，在业务已经确保值唯一的情况下，想要进一步提升性能，可以将唯一索引改为普通索引，这样就可以利用 change buffer 机制，在写多读少的场景中大幅加快查询速度。

3.5讲一下 change buffer 的作用、change buffer 是内存中的一个缓冲区，用于暂时存储对数据的更新操作。也就是说，在需要对一个数据页进行更新时，如果这个数据页就在内存中，那么就直接更新。如果不在内存中，可以不用从磁盘中读取这个数据页，而是将对数据的操作先记录在 change buffer 中，等到真正要查询这个数据页时再将 change buffer 里的内容依次应用，得到正确的数据，这个过程也叫 merge。

除了访问这个数据页会触发 merge，系统后台也会定期进行 merge，数据库正常关闭时也会进行 merge。

change buffer 的优点在于，将更新操作暂存在 change buffer 中，可以减少读磁盘的过程，加快语句的执行。另外，数据读入内存也是需要占用 buffer pool 的，所以这种方法还能避免占用内存，提高内存利用率。

### 3.4我们有时候会听到索引下推，你知道什么是索引下推吗？那覆盖索引又是什么意思呢？

索引下推是 5.6 版本后推出的，是指在索引遍历过程中，对当前索引中包含的字段先做判断，直接过滤掉不满足条件的一些记录，减少回表的次数。比如现在需要根据三个字段限制 A B C 查某个数据，并且已经有了 A,B 的联合索引，5.6 以前是直接根据最左匹配原则，只利用 A 这个索引查主键，然后对所有 A 匹配的行进行回表。现在有了索引下推，可以在 A 匹配成功的同时，利用索引中包含的 B 字段数据，顺便判断一下 B 是否符合，不符合就不用回表了，减少回表次数。

覆盖索引就是根据索引查数据时，如果要查的值已经在索引中了，就不用回表，直接返回结果就行。比如支付模块的支付信息表，包含有订单号和支付状态两个字段。由于经常需要通过订单号去查它的支付状态，可以单独给订单号创建一个普通索引，但考虑到每次只是由订单号查支付状态这一个字段，可以创建一个订单号和支付状态的联合索引，也就是覆盖索引，这样就省去了使用普通索引的回表操作，提高查询效率。