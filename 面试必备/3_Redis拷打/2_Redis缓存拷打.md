## 1. 什么是缓存穿透？
缓存穿透（Cache Penetration） 指的是：
请求的数据在缓存里没有，在数据库里也没有。
结果就是：
每次请求都绕过缓存，直接打到数据库。
主要造成的问题是
如果有人恶意构造大量这种请求，就可能把数据库压垮。

正常请求 GET user:1001，缓存里命中，直接返回。
但有人请求一个不存在的用户 GET user:-1：
缓存没有（因为没存过 -1 这个用户）。数据库查也没有。
每次都查数据库 → 缓存永远不会生效。
如果攻击者批量构造这种“肯定不存在的 key”，数据库就被打爆

### 1.1解决方案是什么？
(1) 缓存空对象
如果数据库查不到数据，可以往缓存里写一个“空值”，并设置较短的过期时间（比如几分钟）。
下次再请求同一个 key，直接命中这个空值，不会继续访问数据库。
缺点：可能缓存大量无效 key，占用空间。

(2) 参数校验
对请求参数做合法性校验，比如 ID 必须是正整数且大于 0。
在到达缓存之前就拦截掉明显无效的请求。

(3) 布隆过滤器（Bloom Filter）
在缓存前面加一层布隆过滤器，把所有合法的 key 都放进去。
查询时先问布隆过滤器，如果判断“不存在”，直接拦截，不访问缓存和数据库。
缺点：布隆过滤器有一定的误判率（会把不存在的误判成存在）。

### 1.2布隆过滤器（Bloom Filter）和参数校验有什么区别
优点：实现简单、开销小，对明显错误的请求能立即挡掉。
缺点：只能过滤掉格式错误/不可能存在的 key，过滤不了合法但实际不存在的数据。
比如 ID=123456 这个数本身合法，但数据库里没有这个用户 → 参数校验拦不住。

布隆过滤器核心思路：用一个概率性数据结构提前记录“可能存在的 key 集合”。
举个例子：
系统里有 1~1亿的用户 ID，把这些 ID 都放进布隆过滤器。
请求过来时，先问布隆过滤器：
说“不可能存在” → 直接拦截，不访问缓存/数据库。
说“可能存在” → 再走缓存和数据库。
优点：能过滤掉大部分不存在的数据，比参数校验更精准。
缺点：有误判率（false positive），会把一些不存在的数据误判成“可能存在”，不过绝不会漏掉真正存在的

## 2. 什么是缓存击穿？

某个 热点 key（比如明星商品详情页、热门文章数据）正好过期的那一刻，大量并发请求同时打过来。
因为缓存里没有了，所有请求会一股脑涌向数据库，造成数据库压力瞬间飙升。
和缓存穿透不同的是：
穿透是“这个 key 根本不存在”。
击穿是“这个 key 本来有，而且是热点，但突然过期了”。

举个例子
双 11 秒杀场景：
商品 ID=1001 是超级热点数据，1 秒内有几百万请求。
平时都走缓存，Redis 扛得住。
但是没秒有几百万请求这个事情持续了很久很久，持续到缓存过期。
那么在缓存过期的那一刻， 瞬间有几百万请求全部打到数据库。结果数据库可能直接被打崩。

### 2. 缓存击穿解决方案是什么？
热点数据永不过期（逻辑过期）
**(1)设置 key 不过期**。
应用层用一个“逻辑过期时间”，超过时间就后台线程异步刷新缓存，而不是直接删。
优点：不会出现大规模同时过期。
**(2)加互斥锁（分布式锁）**
当发现缓存失效时，只有一个线程去数据库里加载数据并更新缓存。
其他线程等待或返回旧数据，避免所有线程同时打到数据库。
**(3)异步预热/自动刷新**
定时任务提前刷新快要过期的热点 key。
或者在访问量大的时候自动延长 TTL，避免过期。


## 3. 缓存雪崩是什么？
大量缓存的 key 在同一时间段内同时过期或不可用，导致本该走缓存的请求全都落到数据库上，瞬间把数据库压垮。
和前两个区别：
穿透：请求的数据缓存和数据库都没有。
击穿：一个热点 key 过期了，大量请求同时打到数据库。
雪崩：一大片 key 一起失效，导致数据库被流量淹没。
系统里所有商品缓存的过期时间都设成 30 分钟整。
30 分钟一到，所有 key 全部失效。
下一个时间点的海量请求都会绕过缓存直击数据库 → 数据库崩溃。
再比如 **Redis 宕机**、**集群不可用**，也会引发缓存雪崩。



### 3.1解决方案是什么？

**(1)过期时间加随机值**
不要让大量 key 在同一时间点过期。
设置过期时间时加一个随机范围，比如 30min + 随机0~5min。
**(2)热点数据永不过期**
类似击穿的解决思路，把核心热点数据设置为不过期，或者后台异步刷新。
**(3)多级缓存**
本地缓存（如 Guava、Caffeine）+ Redis 组合，Redis 挂了还能顶一阵子。
**(4)熔断 & 限流**
在缓存不可用时，对数据库请求做限流、降级，避免数据库直接被打死。

### 3.2你聊到多级缓存，那就讲讲多级缓存是什么吧
多级缓存（Multi-level Cache），就是在系统里 同时使用多个层次的缓存，来减少数据库压力、降低访问延迟。
一般来说是“就近命中”：

(1) 一级缓存：本地缓存
部署在应用进程内存里（JVM 里可以用 **Guava Cache**、**Caffeine**）。
访问速度最快（纳秒级，走进程内存，不需要网络）。
适合缓存热点小数据、配置项、用户 Session。
缺点：每个应用节点都有一份，数据不一致、容量有限。

(2) 二级缓存：分布式缓存（Redis）
多个应用节点共享一份缓存。
容量大、数据一致性好。
访问速度比本地缓存慢一些（要走网络），但比数据库快很多。

(3) 三级缓存（可选）：数据库自带缓存/OS 缓存
比如 MySQL 的 Buffer Pool、操作系统的页缓存。
应用层一般不用直接控制，但它也是缓存体系的一部分。

#### 3.2.1MySQL 的 Buffer Pool、操作系统的页缓存是什么，聊一聊？

假设我们要 SELECT * FROM user WHERE id = 123;
并且这个数据既不在 Redis，也不在 MySQL Buffer Pool，更不在操作系统 Page Cache。
1. 应用层检查缓存
应用（Java等）先查 本地缓存（Caffeine/Guava） → 没命中。
再查 Redis → 也没命中。
👉 所以请求落到数据库。

2. MySQL 层
MySQL 收到 SQL，先看 Buffer Pool（InnoDB 的缓存区）。
没命中（说明这页数据还没被加载过）。
MySQL 需要读磁盘文件，就发起系统调用（read）。

3. 操作系统层
内核先检查 **Page Cache（OS 文件缓存）**。
没命中（说明这块磁盘数据从没被加载到内存过）。
系统只好向存储设备（SSD/HDD）发起真正的磁盘 I/O。

### 3.3你聊到熔断 & 限流，那就讲讲熔断 & 限流是什么吧

### 3.4Redis 宕机、集群不可用，是怎么引发缓存雪崩的？

## 4.缓存一致性问题是什么



### 4.1 有哪些解决方案？