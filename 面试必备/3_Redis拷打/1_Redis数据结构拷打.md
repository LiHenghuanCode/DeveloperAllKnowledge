




## 1. Redis有哪些常见数据结构以及应用场景


常见的数据结构有：字符串String、哈希表Hash、列表List、集合Set、有序集合Sorted Set。除了这些，还有 Bitmaps、HyperLogLog、GEO，甚至还可以自定义数据结构。

**1、String – 字符串**
String 类型是 Redis 最基础的数据结构，其它几种数据结构都是在字符串类型的基础上创建的。并且所有数据结构的 **key** 也都是字符串类型。

String 类型只能存储单个数据，即一个 **key** 对应一个 **value**。同时它还是二进制安全的，意思就是 String 类型严格按照二进制数据进行存取。

正因如此，它可以存储任何数据，包括字符串：简单的字符串，复杂的 JSON，XML 字符串；数字：整数，浮点数；甚至是二进制：图片，音频，视频等。

String 类型的内部编码有三种：int，embstr，raw，分别在当前值为 8 字节长整形，小于等于 39 字节的字符串，大于 39 字节的字符串时使用。

Redis 会根据当前 String 的值类型和大小自己决定使用哪种内部编码实现。

使用场景：
（1）充当缓冲：缓存用户的基本信息
这是一个最容易被想到的应用场景：由于用户基本信息更改频率比较低，但是像用户昵称，头像这些基本信息会用的比较频繁，所以我们可以对他进行缓存，例如：可以将 MySQL 中每个用户的信息转换为 JSON 格式存储在 String 类型中。

（2）计数
String 类型天然可自增，利用 incr 命令可以实现快速计数功能，同时它还是原子性的操作。比如可以用来记录网站上视频的播放量。

（3）在一段时间内限制请求次数
比如为了防止用户恶意刷新网页，可以限制一个 IP 地址在一段时间内刷新网页的次数。其伪代码为：

（4）分布式共享 Session
通常每个服务器只会存储自己的 Session，考虑在负载均衡的情况下，分布式服务会将用户的访问均衡到不同的服务器上，此时用户的信息只存在一个服务器上显然是不合适的。
这时就可以考虑使用 Redis，将所有用户的 Session 信息进行集中管理，各个服务器在需要读取用户信息时，只需向 Redis 中查询即可。

**2、Hash - 哈希表**
Redis 中的 Hash 类型是一个键值对集合，一个 key 对应多个 field - value 键值对，且不允许重复。

内部编码：

Hash 类型的内部编码有两种： ziplist（压缩列表），dict（字典）。当元素个数少时使用 zipllist，否则使用 dict。

ziplist 使用非常紧凑的结构实现多个元素的连续存储，在节省内存方面比 hashtable 优秀。

但是当元素多时，ziplist 的读写效率会下降，这时 hashtable 的优势就体现出来了，它的读写时间复杂度仅为 O(1)
所以在 Hash 类型元素多时，内部编码会自动完成从 ziplist 到 hashtable 的转变，以保证读写效率。

Reids 5 提供了一种新的数据结构 listpack，用来代替 Hash 和 Zset 类型中的 ziplist 。它的特点也是用一块连续的内存空间紧凑的存储数据，但不同于 ziplist，listpack 每个列表项只记录自己的长度，而不会记录前一列表项的长度，从而避免了连锁更新。

**3、List - 列表**
List 类型存储的是多个有序的字符串，其中的“有序”指的是插入时间上的先后顺序。

它是一种比较灵活的数据结构，可以充当栈和队列的角色。

列表类型有两个特点：首先是列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。其次是列表的元素可重复。

内部编码：

列表类型有两种编码：ziplist，linkedlist（双向链表）。当元素个数少且每个元素的值也小时使用 zipllist，其它情况下则使用 hashtable。

Redis 3.2 版本提供了 quicklist 内部编码，之后取代了 List 类型的 ziplist 和 linkedlsit ，它结合了 ziplist 和 linkedlist 两者的优势，进一步压缩了内存的使用量，进一步提高了效率。

使用场景：

（1）消息队列
List 类型提供的 LPUSH + RPOP 命令组合可以实现一个简易版的”消息队列“。生产者使用 LPUSH 命令在列表左侧插入消息，消费者使用 RPOP 命令在列表的右侧获取消息。
但是如果使用这种方案的话，消费者在读取消息时，有一个潜在的性能风险：
生产者在往列表中写入消息时，并不会主动的通知消费者有新消息写入列表了。消费者需要在一个循环中不停地调用 RPOP 命令，来确保能够及时的处理消息。
这样的话，即使一段时间内没有新消息到达，消费者也要不断循环“试探”，浪费了 CPU 性能。
Redis 提供的 BRPOP 命令可以用来解决这个问题。BRPOP 命令是 RPOP 的阻塞版本，当列表中没有任何元素可以弹出时，连接将被 BRPOP 命令阻塞，直到连接超时或者有元素可弹出为止。
为了方便理解，可以看下图：
（2）模拟基础的数据结构：栈和队列
栈的特点为”先进后出“，我们可以用 List 类型的 LPUSH + LPOP 命令实现，从左边添加元素，再从左边弹出元素。
队列的特点为”先进先出“，我们可以用 List 类型的 LPUSH + RPOP 命令实现，从左边添加元素，从右边弹出元素。

**4、Set - 集合**
Set 类型也是用来保存多个字符串元素，它的特点和 List 类型恰好相反：Set 类型不允许有重复元素，并且其中的元素都是无序的。其中 Set 类型的自动去重功能在实际应用中非常关键。

Redis 除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。

内部编码：

Set 类型的内部编码有两种：intset（整数集合），hashtable（哈希表），当集合中的元素都是整数且元素个数少时，Redis 会用 intset 来作为内部编码。其它情况下则会用 hashtable 作为集合内部实现。

使用场景：

（1）点赞列表（集合内操作）

Set 类型可以保证在一篇文章下，一个用户只能点赞一次。

下面使用集合类型实现点赞列表的若干功能。

**5、Zset - 有序集合**
顾名思义，Redis 中的 Zset 类型中的成员是有序排列的。它和 Set 类型的相同之处在于：集合中的每个元素都是 字符串类型，并且不允许重复。

而它们最大的区别在于，Zset 类型是有序的，Set 类型是无序的。

原因在于 Zset 类型相比于 Set 类型多了一个排序属性 score（分值），它的排序功能正是通过 score 作为依据来实现的。

内部编码：

有序集合的内部编码有两种：ziplist（7.0 之后替换为 listpack），skiplist（跳表）。当元素个数少且每个元素的值也小时使用 zipllist，其它情况下则使用 dict + skiplist。
使用场景：
（1）排行榜
Zset 类型比较典型的使用场景就是排行榜，并且可以依据多个维度（点赞，播放量，时间）实现榜单。例如播放量最高的视频，点赞数最多的文章，商品的销量排名等
（2）电话，姓名排序
Zset 还支持按照 key 来进行排序，使用 ZRANGEBYLEX 命令。
需要注意的是：此操作返回指定区间的元素，按 key 正序排列，其 score 必须相同，否则结果将不准确。
可以使用此特性来实现电话，姓名的排序。

6、Bitmaps
可以把 Bitmaps 想象成一个以位（bit）为单位的数组，数组的每个单元只能存储 0 和 1，数组的下标在 Bitmaps 中叫做偏移量（从 0 开始算起）。如图：
使用场景：
Bitmaps 类型非常适合二值统计的场景，同时由于元素的取值只有 0 和 1 两种，在记录海量数据时，Bitmaps 能有效的节省内存空间。
（1）签到统计
在签到统计场景中，我们只需记录签到（1）或未签到（0），此时用 Bitmaps 就非常合适。
每个用户一天的签到用 1 个 bit 就能表示，那么一个月的签到情况用 30 个 bit 就能表示，一年的签到也只用 365 个 bit 就能表示。

（2）记录独立用户访问网站的情况
类似于签到统计，可以将每个独立用户是否访问过网站存放在 Bitmaps 中，将访问的用户记做 1，没有访问的用户记做 0，用偏移量作为用户的 id。例如：
其它操作类似，参考使用场景（1）。

7、HyperLogLog
HyperLogLog 是一种基数算法，即用来统计一个集合中不重复元素的个数。通过 HyperLogLog 可以利用极小的内存空间完成独立总数的统计，数据集可以是 IP，Email，ID 等，
HyperLogLog 的基本特征是它只做基数计算，不会保存元数据。
它的内存占用量小得惊人，使用 Set 类型和 HyperLogLog 类型统计百万级用户的占用空间对比如下图：
但是利用如此小的空间能计算如此大的数据，其结果必然具有一定误差，误差在 
0.81%左右。
使用场景：
Redis 提供的 HyperLogLog 类型一共只有三个命令：PFADD，PFCOUNT，PFMERGE。下面以统计访问 IP 为例：
**8、GEO**
GEO 类型主要用来实现地理信息定位功能，它使用 GeoHash 算法将二维的经纬度数据映射成一维二进制数组，并支持对这些数据进行操作。

日常生活中，我们在地图软件上使用的 “附近的餐馆”、”叫车“ 都属于基于位置信息服务（Location-Based Service，LBS）的应用。

LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。
**9、Stream**
Stream 类型是 Redis 5.0 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令。
它的设计满足消息队列的三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。下面通过这三个要求来介绍 Stream。
（1）消息保序
Stream 类型本身就是按照先进先出的顺序对数据进行存取的，所以，Stream 已经满足消息保序的需求了。
（2）处理重复消息
生产者可以使用 Stream 类型的 XADD 命令，以键值对的方式插入一条消息，插入后的消息可以保证其有序。
原因在于使用此命令时，可以在消息队列名称后面带上 * 号，那么插入的消息将自动生成全局唯一 ID。
（3）保证消息可靠性
为了保证某个消费者宕机重启后，仍然可以读取未处理完的消息。Stream 使用了内部队列（PENDING List）来留存每个消费者需要读取的信息，直到消费者使用 XACK 命令通知 Stream ”消息已经处理完成“。
如果消费者没有成功处理消息，Stream 就不会收到 XACK 命令，此时消息仍会留存在 PENDING List 中。在消费者恢复后，可使用 XPENDING 命令查看已经读取，但还未确认处理完成的消息。
（4）消费组
除上述之外，Stream 本身支持使用 XGROUP 创建消费组，消费组的目的为让组内的多个消费者共同分担读取消息，实现消息读取负载在多个消费者间是均衡的。
在消费组中，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。

##


##

##

##

##

##

##