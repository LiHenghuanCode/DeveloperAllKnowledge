## 1.介绍一下 Object 常见方法？

回答思路：

列举一下...，
然后具体来说... 1是什么，通常用来干什么，实践中会怎么做

Object 类常见的方法有 `toString( )`，`equals( ) `和 ` hashCode( )`，`wait( )` 和 `notify( ) `等等。

具体来说：
`toString( ) `返回的是**对象的字符串表示**，默认为 「class 名 + @ + hashCode 的十六进制表示」，在实践中，我们一般会在子类将它重写为打印各个字段的值，在调试和打日志中用的多。
`equals( ) ` 输入两个对象作为参数，返回一个布尔值，通常这个方法会与` hashCode( )`一起使用，因为`equals( ) `在没有被重写的情况，其功能等价于`==` 。换句话说`equals( ) `默认情况下比较的是两个对象的哈希值，哈希值可以通过` hashCode( )`方法获取，其返回值默认以对象的内存地址为参考。在实践中，为了保证元素在 `HashSet` 和 ` HashMap` 等集合中的正确存储，通常需要将它俩一起重写。
`wait( )` 和 `notify( ) `，这是线程间通信的方法，必须在同步块（synchronized）中调用，实现线程之间的协调，例如**生产者–消费者模式**。具体实践当中在一个线程里调用 wait() 进入等待，在另一个线程里调用 notify() 或 notifyAll() 唤醒，确保在共享锁对象上调用。

## 2.Java为什么被称为平台无关性语言？

因为JVM。具体地说， Java 源代码经过编译后会生成与平台无关的字节码，这些字节码依赖 **JVM** 来执行。不同平台只需提供各自实现的 JVM，JVM 会把字节码解释或即时编译为该平台的机器指令，从而实现“一次编写，到处运行”的特性。

## 3.==和equals()有什么区别？

== 是一个操作符 ，`equals() `是超类 Object 中的方法。对于没有重写 `equals` 方法的子类，`equals `和 = = 是一样的。而 == 在比较时，根据所比较的类的类型不同，功能也有所不同：对于基础数据类型，如 int 类型等，比较的是**具体的值**；而对于**引用数据类型**，比较的是引用的地址是否相同。对于重写的 equals 方法，比的内容取决于这个方法的实现。

## 4.讲一下`equals()`与`hashcode()`，什么时候重写，为什么重写，怎么重写？

equals() 和 hashcode() 都是Object 中的方法。hashcode()会返回哈希值，所谓哈希值就根据一定的规则将与对象相关的信息，比如对象的内存地址，映射成一个数值，这个数值称作为哈希值。

当我们想要自定义类的比较规则时，需要重写 equals( )，但是为了保证类在 HashSet 和 HashMap 等集合中的正确存储，也要同时重写 hashCode( )。

以 HashMap 为例， HashMap底层在添加相同的元素时，会先调用两个对象的 hashCode( ) 是否相同，如果相同还会再用 equals( ) 比较两个对象是否相同

假设有一个 Person 类，有 name 和 age 两个字段，我们现在重写 equals( ) 规定只有两个 Person 的 name 和 age 都相同时，才认为两个 Person 相等。

现在 new 出两个 name 和 age 都相同的 Person，分别添加到 HashMap 中。我们期望最后 HashMap 中只有一个 Person，但是如果没有按照一定规则重写hashCode( )，HashMap里最后会有两个。因为添加第二个 Person 时，先比较的是两个 Person 的 hashCode( )。在没有重写 hashCode( )的情况 ，那么分别 new 出来的 Person 的**哈希值肯定是不同的**，到这里 HashMap 就会将两个 Person 认定为不同的元素添加进去。

解决的办法就是重写 hashCode( )，最简单的返回 name 和 age 的哈希值的乘积即可。

## 5.讲一下重载和重写的区别？

从定义上讲，重载是指在**同一个类中定义多个方法**，它们具有相同的函数名，但参数的类型，个数和顺序可能不同。它提供了一种灵活的方式来实现相似的功能。重写是指在**子类中重新定义并覆盖父类中的方法**。它使子类可以根据具体的类型调用相应的方法实现。

从原理上讲，在 JVM 中，方法重载对应 “静态分配” 的过程，也就是 JVM 在编译期就根据参数的静态类型，决定了会使用函数的哪个重载版本而方法重写对应 “动态分配” 的过程，具体的，重写方法的调用是由字节码中的 invokevirtual 指令实现的，而 invokevirtual 指令会在运行期间，根据方法接受者的实际类型来选择方法的执行版本。

## 6.抽象和接口的区别？

抽象在 Java 中是指被 abstract 修饰的类或方法，接口是指被 interface 修饰的类。接口中声明的方法，默认也被定义为 abstract。抽象主要是为了代码复用。比如一些类拥有一些通用的功能，为了不在每一类中重新写一遍这个方法的代码，就可以定义一个抽象类，这样一来，只需让每一个类继承抽象类就可以了，如果后期需要修改方法，只需要修改抽象类中的方法就行，如果子类想要自己实现不一样的行为，只需子类重写抽象类的方法。

这样一来，普通类就可以完成这个工作，为什么需要抽象类，**抽象类还起了一个限制作用** ，比如要求每一个子类必须自己独特实现的一个方法，也是抽象类定义的抽象方法。

缺点也很明显，因为Java没有多继承，导致一个类只能继承一个父类。在表示是什么的关系时，一般使用抽象类。

接口更多的是为了解耦。比如我需要制定一套方法的规范，就可以将这套方法规范抽象为一个接口。每一个继承这个接口的类都必须实现接口中所有的方法。在表示有什么的关系时，使用接口。

## 7.谈一谈你对 final 关键字的理解？什么需要用这个关键字来定义呢

final是Java中的一个关键字，可以用来修饰类、方法、变量。

当用final来修饰类时，表示这个类不可以被继承，可以确保一些安全性，防止类被纂改。而final用来修饰方法，表示方法不可以被重写，final修饰变量时，如果是基本数据类型，值不变。

如果是引用类型，引用指向的地址值不变，但地址的内容可能会变。final可以用来解决一些安全性问题。比如Java的一些核心类库的类的API接口不想被纂改就使用final修饰方法。

Java希望String类是不可变的，就使用final修饰String类并且修饰成员变量char[]数组，并且没有提供setter方法，这样就可以确保String类是不可变的。

另外，如果有多个线程操作同一个变量，并且这个变量的值不会变化，可以考虑使用final修饰解决线程安全问题。


## 8.聊一聊你对多态的理解？

多态可以理解为 “事物运行时的不同状态”，在 Java 中具体指，通过动态绑定，在运行时根据对象的实际类型来调用对应的方法。多态可以通过继承或者接口来实现。拿继承来说，子类必须重写父类的方法，通过向上转型，使用父类类型来调用子类对象的方法，结果是在运行时执行子类中重写的方法。


## 9.String 五连击按照提问逐一回答


### 1、String 为什么要设计为不可变类？（指导：可以从安全性，性能等方面来考虑）

这个主要是出于线程安全和性能方面的考虑。线程安全体现在，由于 String 是不可变的，多个线程共享一个 String 时不用担心它的同步问题；性能体现在缓存哈希值和设计常量池上。String 在被创建时就缓存了自己的哈希值，使用时直接拿出来就行，不用重新计算，这使得 String 适合用来作为 Map 的 Key，可以快速获得 Key 的哈希值，提高查找和比较的效率；除此之外，基于 String 的不可变，Java 使用常量池来尽可能的共享相同的字符串，来节约 String 的存储空间。具体的，当我们使用字面值创建 String 时，会先去查它是否已经存在于常量池中，如果是则直接返回这个已存在字符串的引用，而不会创建新的对象。

### 2、String a = new String(“aa”) + “bb” “这句话创建了多少个对象？为什么？（指导：没啥好说，这种笔试考的多）

共创建了 4 个 String 对象，第一个是常量池中的对象 “aa”，如果常量池中有 “aa” 就直接返回，没有就创建并添加进常量池中。第二个是 new 出来的以 “aa” 为初始值创建的 String 对象，第三个 “bb” 同 “aa”，第四个是通过 “+” 拼接前两个对象，创建出的新 String 对象。

### 3、String 对象最多可以存放多少个字符（长度）？（指导：可以从源码角度分析勒）

String 在源码中使用 char[] 来维护字符序列的，而 char[] 的长度是 int 类型，所以理论上 String 的长度最大为 2^31−1 ，占用空间大约为 4 GB，不过根据实际 JVM 的堆内存限制，编译时，String长度最多可以是2的16次方减2，运行时长度最多可以是2的31次方减1，意思是可以在编译时定义一些短的字符串，运行时可以进行拼接，长一点也可以。

### 4、字符串常量池是放在堆中吗？

不是，Java 8 以前被放在永久代中，Java 8 及以后被放在方法区的元数据 metadata 中。

### 5、String中 “+” 和 StringBuffer 中的 append 会有性能上的差别吗？

String 的 “+” 效率低于 StringBuffer 的 append( )。原因在于 String 是不可变类，任何对 String 的操作都会创建新的 String 对象。而 “+” 的执行过程实际上是先创建了一个 StringBuffer，然后调用 append( )，最后在 toString( )。效率上肯定是不如 StringBuffer 直接 append( ) 高的。

### 6.StringBuilder、StringBuffer有什么区别？

StringBuilder 和 StringBuffer 都是可变类，任何对它们的操作都不会产生新的对象。两者的区别在于：StringBuilder 没有加锁不是线程安全的，而 StringBuffer 大多数方法都加了 synchronized，是线程安全的，但执行效率会低点。

源码中有一个细节，就是 StringBuffer 的 append 方法在执行真正的字符串拼接逻辑之前，会先清除 toStringCache，它是用来缓存最后一次 toString 结果的地方，主要用来加快 toString 的执行效率。
