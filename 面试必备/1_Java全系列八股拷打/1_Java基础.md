## 0.前言
Java基础（以宏观概念为主）
谈一些比较空泛的问题，就像打嘴炮一样

## 1. Java的优势有哪些


第一点是跨平台性。Java 是运行在 JVM 上的，所以只要有 JVM 的地方，同一份代码就能跑，不管是 Windows、Linux 还是 Mac。
第二点是内存管理。Java 内置垃圾回收机制，开发者不用像 C/C++ 那样手动管理内存，这大大降低了内存泄漏和指针错误的风险。
第三点是生态和类库非常丰富。不管是后端的 Spring、还是大数据领域的 Hadoop、Spark，都有很成熟的解决方案，这也是 Java 能在企业级开发里一直保持主流的原因。
第四点是并发支持。Java 的并发包设计得很完善，比如线程池、并发容器、AQS 这些，都让我们处理高并发场景更轻松。**这一点慎重，一旦你选择回答，面试官可能追问你并发相关知识**
最后就是面向对象的特点。Java 天生就是 OOP 语言，封装、继承、多态这些特性让代码更容易维护和复用，也方便做大型系统的架构设计。**这一点慎重，一旦你选择回答，面试官可能追问你非面向对象语言有哪些**



## 2. Java的面向对象特性是指什么？
Java 的三大核心特性是 封装、继承和多态。

封装就是把数据和方法绑定在一起，对外只暴露必要的接口，外部“看不见”内部实现细节。这样做可以提高安全性，也让代码更容易维护。比如类的私有属性通过 getter/setter 来访问。

继承就是子类可以复用父类的代码，也可以扩展新的功能。这让代码复用性更强，也便于维护。比如我们写一个 Animal 父类，不同的 Dog、Cat 子类都能继承它的通用方法。

多态就是同一个方法在不同对象上有不同表现。它分为**编译期多态（方法重载）和运行期多态（方法重写，动态绑定）**。这使得我们可以面向接口编程，提高灵活性和扩展性。 **这里很有可能被追问多态相关**

## 3. 重载和重写的区别
重载 (Overload) 发生在**同一个类**里，方法名相同，但参数列表必须不同（参数个数、类型、顺序）。它跟返回值类型无关。重载在编译期就能确定调用哪个方法，所以也叫 编译时多态。常见的例子就是 System.out.println()，可以传 int、String、Object 等

重写 (Override) 则发生在**子类和父类**之间，方法名、参数列表必须完全相同，返回值类型要兼容，访问修饰符不能比父类更严格。它是在运行时根据对象的实际类型来决定调用哪个方法，所以叫 运行时多态。比如子类重写父类的 toString() 方法

## 4. 接口和抽象类的区别
**建议自己实践一下**
设计目的不同。接口更强调一种 规范，就是“你必须实现哪些方法”，接口里的方法默认是抽象的；而抽象类更像是一种 模板，它可以提供部分实现，也可以把部分变成抽象方法，子类继承后再具体实现，也可以在此基础上实现其他方法。第三，继承限制不同。Java 里一个类只能继承一个抽象类，但是可以实现多个接口，这就让接口更适合做“多重能力扩展”。

## 5.为什么不支持多重继承
你能被问到这个问题，那要恭喜你了，这个问题很自由，一般是面试官觉得你懂得多才会问
Java 不支持类的多重继承，主要是为了避免 菱形继承问题 和 设计复杂性。
第一，菱形继承问题。
假设有一个类 A，B 和 C 都继承自 A，然后 D 同时继承 B 和 C。
那么如果 A 里有一个方法 foo()，而 B、C 又都重写了 foo()，那 D 到底该继承哪一个版本？这就产生了 二义性。
第二，复杂性和可维护性。
多重继承会让类关系变得非常复杂，容易导致可读性和可维护性差。
所以 Java 的设计者选择只支持 单继承 + 多实现：
类只能继承一个父类；
但可以实现多个接口，这样既避免了多重继承的二义性，又能获得多态的灵活性。
从 JDK 8 开始，接口还能有 default 方法，进一步弥补了多重继承的不足，但依然避免了复杂的冲突

## 5.1 那为什么C++支持多重继承
**建议自己手动实践一下**
C++ 支持多重继承，是因为它更强调 灵活性和底层控制，同时提供了机制来解决多重继承带来的二义性。
第一，C++ 更贴近底层。它的设计目标之一是给开发者最大的自由度，包括直接操作内存、多继承、运算符重载等。这种灵活性带来强大功能，但同时也增加了复杂性。
第二，虚继承机制。
C++ 引入了 虚继承 (virtual inheritance) 来解决菱形继承问题。
举个例子，如果 B 和 C 都继承 A，D 同时继承 B 和 C，那么通过虚继承，D 里只会保留一份 A 的成员，从而避免二义性。
第三，适用场景。
在一些系统编程或底层库设计中，多重继承可以减少类层次结构的复杂度，避免过多的接口或模板组合。
但是相对来说，C++ 的多重继承写起来复杂，容易引发维护困难，所以在实际工程中也并不常用。很多 C++ 开发者也更倾向于 单继承 + 接口类（纯虚类） 的方式



## 1.介绍一下 Object 常见方法？

回答思路：

列举一下...，
然后具体来说... 1是什么，通常用来干什么，实践中会怎么做

Object 类常见的方法有 `toString( )`，`equals( ) `和 ` hashCode( )`，`wait( )` 和 `notify( ) `等等。

具体来说：
`toString( ) `返回的是**对象的字符串表示**，默认为 「class 名 + @ + hashCode 的十六进制表示」，在实践中，我们一般会在子类将它重写为打印各个字段的值，在调试和打日志中用的多。

`equals()` 方法用于比较两个对象是否相等，返回布尔值。在 `Object` 类中，默认的 `equals()` 实现与 `==` 等价，也就是说，它只是判断两个引用是否指向同一个对象。`hashCode()` 方法默认返回一个整数，这个整数通常由对象的内存地址计算得到。实际应用场景中，特别在使用基于哈希表的数据结构，比如 **`HashSet`**、**`HashMap`**。我们一般会选择重写 `hashCode()`。因为当我们向哈希表中添加一个对象时，基于哈希表的数据结构会先调用 `hashCode()` 确定对象中的桶，再通过 `equals()` 方法判断是否是同一对象。实际开发中如果我们想通过对象的内容比如其各成员变量来判断相等性，我们需要同时重写 `equals()` 和 `hashCode()` 方法。这是因为不同对象即便其内容（成员变量）相同，其内存地址可能不同导致 `equals()` 方法返回非预期结果；其次两个对象即便内容不同，它们的默认的 `hashCode()` 也可能相同。

`wait( )` 和 `notify( ) `，这是线程间通信的方法，必须在同步块（synchronized）中调用，实现线程之间的协调，例如**生产者–消费者模式**。具体实践当中在一个线程里调用 wait() 进入等待，在另一个线程里调用 notify() 或 notifyAll() 唤醒，确保在共享锁对象上调用。




## 4.String 五连击按照提问逐一回答

### 4.1、String 为什么要设计为不可变类？（指导：可以从安全性，性能等方面来考虑）

这个主要是出于线程安全和性能方面的考虑。线程安全体现在，由于 String 是不可变的，多个线程共享一个 String 时不用担心它的同步问题；性能体现在缓存哈希值和设计常量池上。String 在被创建时就缓存了自己的哈希值，使用时直接拿出来就行，不用重新计算，这使得 String 适合用来作为 Map 的 Key，可以快速获得 Key 的哈希值，提高查找和比较的效率；除此之外，基于 String 的不可变，Java 使用常量池来尽可能的共享相同的字符串，来节约 String 的存储空间。具体的，当我们使用字面值创建 String 时，会先去查它是否已经存在于常量池中，如果是则直接返回这个已存在字符串的引用，而不会创建新的对象。

### 4.2、String a = new String(“aa”) + “bb” “这句话创建了多少个对象？为什么？（指导：没啥好说，这种笔试考的多）

共创建了 4 个 String 对象，第一个是常量池中的对象 “aa”，如果常量池中有 “aa” 就直接返回，没有就创建并添加进常量池中。第二个是 new 出来的以 “aa” 为初始值创建的 String 对象，第三个 “bb” 同 “aa”，第四个是通过 “+” 拼接前两个对象，创建出的新 String 对象。

### 4.3、String 对象最多可以存放多少个字符（长度）？（指导：可以从源码角度分析勒）

String 在源码中使用 char[] 来维护字符序列的，而 char[] 的长度是 int 类型，所以理论上 String 的长度最大为 2^31−1 ，占用空间大约为 4 GB，不过根据实际 JVM 的堆内存限制，编译时，String长度最多可以是2的16次方减2，运行时长度最多可以是2的31次方减1，意思是可以在编译时定义一些短的字符串，运行时可以进行拼接，长一点也可以。

### 4.4、字符串常量池是放在堆中吗？

不是，Java 8 以前被放在永久代中，Java 8 及以后被放在方法区的元数据 metadata 中。

### 4.5、String中 “+” 和 StringBuffer 中的 append 会有性能上的差别吗？

String 的 “+” 效率低于 StringBuffer 的 append( )。原因在于 String 是不可变类，任何对 String 的操作都会创建新的 String 对象。而 “+” 的执行过程实际上是先创建了一个 StringBuffer，然后调用 append( )，最后在 toString( )。效率上肯定是不如 StringBuffer 直接 append( ) 高的。

### 4.6.StringBuilder、StringBuffer有什么区别？

StringBuilder 和 StringBuffer 都是可变类，任何对它们的操作都不会产生新的对象。两者的区别在于：StringBuilder 没有加锁不是线程安全的，而 StringBuffer 大多数方法都加了 synchronized，是线程安全的，但执行效率会低点。

源码中有一个细节，就是 StringBuffer 的 append 方法在执行真正的字符串拼接逻辑之前，会先清除 toStringCache，它是用来缓存最后一次 toString 结果的地方，主要用来加快 toString 的执行效率。


## 4.Java为什么被称为平台无关性语言？

因为JVM。具体地说， Java 源代码经过编译后会生成与平台无关的字节码，这些字节码依赖 **JVM** 来执行。不同平台只需提供各自实现的 JVM，JVM 会把字节码解释或即时编译为该平台的机器指令，从而实现“一次编写，到处运行”的特性。

## 5.讲一下重载和重写的区别？

从定义上讲，重载是指在**同一个类中定义多个方法**，它们具有相同的函数名，但参数的类型，个数和顺序可能不同。它提供了一种灵活的方式来实现相似的功能。重写是指在**子类中重新定义并覆盖父类中的方法**。它使子类可以根据具体的类型调用相应的方法实现。

从原理上讲，在 JVM 中，方法重载对应 “静态分配” 的过程，也就是 JVM 在编译期就根据参数的静态类型，决定了会使用函数的哪个重载版本而方法重写对应 “动态分配” 的过程，具体的，重写方法的调用是由字节码中的 invokevirtual 指令实现的，而 invokevirtual 指令会在运行期间，根据方法接受者的实际类型来选择方法的执行版本。

## 6.抽象和接口的区别？

抽象在 Java 中是指被 abstract 修饰的类或方法，接口是指被 interface 修饰的类。接口中声明的方法，默认也被定义为 abstract。抽象主要是为了代码复用。比如一些类拥有一些通用的功能，为了不在每一类中重新写一遍这个方法的代码，就可以定义一个抽象类，这样一来，只需让每一个类继承抽象类就可以了，如果后期需要修改方法，只需要修改抽象类中的方法就行，如果子类想要自己实现不一样的行为，只需子类重写抽象类的方法。

这样一来，普通类就可以完成这个工作，为什么需要抽象类，**抽象类还起了一个限制作用** ，比如要求每一个子类必须自己独特实现的一个方法，也是抽象类定义的抽象方法。

缺点也很明显，因为Java没有多继承，导致一个类只能继承一个父类。在表示是什么的关系时，一般使用抽象类。

接口更多的是为了解耦。比如我需要制定一套方法的规范，就可以将这套方法规范抽象为一个接口。每一个继承这个接口的类都必须实现接口中所有的方法。在表示有什么的关系时，使用接口。

## 7.谈一谈你对 final 关键字的理解？什么需要用这个关键字来定义呢

final是Java中的一个关键字，可以用来修饰类、方法、变量。

当用final来修饰类时，表示这个类不可以被继承，可以确保一些安全性，防止类被纂改。而final用来修饰方法，表示方法不可以被重写，final修饰变量时，如果是基本数据类型，值不变。

如果是引用类型，引用指向的地址值不变，但地址的内容可能会变。final可以用来解决一些安全性问题。比如Java的一些核心类库的类的API接口不想被纂改就使用final修饰方法。

Java希望String类是不可变的，就使用final修饰String类并且修饰成员变量char[]数组，并且没有提供setter方法，这样就可以确保String类是不可变的。

另外，如果有多个线程操作同一个变量，并且这个变量的值不会变化，可以考虑使用final修饰解决线程安全问题。


## 8.聊一聊你对多态的理解？

多态可以理解为 “事物运行时的不同状态”，在 Java 中具体指，通过动态绑定，在运行时根据对象的实际类型来调用对应的方法。多态可以通过继承或者接口来实现。拿继承来说，子类必须重写父类的方法，通过向上转型，使用父类类型来调用子类对象的方法，结果是在运行时执行子类中重写的方法。


