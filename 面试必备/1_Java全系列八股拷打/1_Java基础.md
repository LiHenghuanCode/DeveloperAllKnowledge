## 0.前言
Java基础（以宏观概念为主）
谈一些比较空泛的问题，就像打嘴炮一样

## 1. Java的优势有哪些


第一点是跨平台性。Java 是运行在 JVM 上的，所以只要有 JVM 的地方，同一份代码就能跑，不管是 Windows、Linux 还是 Mac。
第二点是内存管理。Java 内置垃圾回收机制，开发者不用像 C/C++ 那样手动管理内存，这大大降低了内存泄漏和指针错误的风险。
第三点是生态和类库非常丰富。不管是后端的 Spring、还是大数据领域的 Hadoop、Spark，都有很成熟的解决方案，这也是 Java 能在企业级开发里一直保持主流的原因。
第四点是并发支持。Java 的并发包设计得很完善，比如线程池、并发容器、AQS 这些，都让我们处理高并发场景更轻松。**这一点慎重，一旦你选择回答，面试官可能追问你并发相关知识**
最后就是面向对象的特点。Java 天生就是 OOP 语言，封装、继承、多态这些特性让代码更容易维护和复用，也方便做大型系统的架构设计。**这一点慎重，一旦你选择回答，面试官可能追问你非面向对象语言有哪些**



## 2. Java的面向对象特性是指什么？
Java 的三大核心特性是 封装、继承和多态。

封装就是把数据和方法绑定在一起，对外只暴露必要的接口，外部“看不见”内部实现细节。这样做可以提高安全性，也让代码更容易维护。比如类的私有属性通过 getter/setter 来访问。

继承就是子类可以复用父类的代码，也可以扩展新的功能。这让代码复用性更强，也便于维护。比如我们写一个 Animal 父类，不同的 Dog、Cat 子类都能继承它的通用方法。

多态就是同一个方法在不同对象上有不同表现。它分为**编译期多态（方法重载）和运行期多态（方法重写，动态绑定）**。这使得我们可以面向接口编程，提高灵活性和扩展性。 **这里很有可能被追问多态相关**

## 3. 重载和重写的区别
重载 (Overload) 发生在**同一个类**里，方法名相同，但参数列表必须不同（参数个数、类型、顺序）。它跟返回值类型无关。重载在编译期就能确定调用哪个方法，所以也叫 编译时多态。常见的例子就是 System.out.println()，可以传 int、String、Object 等

重写 (Override) 则发生在**子类和父类**之间，方法名、参数列表必须完全相同，返回值类型要兼容，访问修饰符不能比父类更严格。它是在运行时根据对象的实际类型来决定调用哪个方法，所以叫 运行时多态。比如子类重写父类的 toString() 方法

## 4. 接口和抽象类的区别
**建议自己实践一下**
设计目的不同。接口更强调一种 规范，就是“你必须实现哪些方法”，接口里的方法默认是抽象的；而抽象类更像是一种 模板，它可以提供部分实现，也可以把部分变成抽象方法，子类继承后再具体实现，也可以在此基础上实现其他方法。第三，继承限制不同。Java 里一个类只能继承一个抽象类，但是可以实现多个接口，这就让接口更适合做“多重能力扩展”。

## 5.为什么不支持多重继承
你能被问到这个问题，那要恭喜你了，这个问题很自由，一般是面试官觉得你懂得多才会问
Java 不支持类的多重继承，主要是为了避免 菱形继承问题 和 设计复杂性。
第一，菱形继承问题。
假设有一个类 A，B 和 C 都继承自 A，然后 D 同时继承 B 和 C。
那么如果 A 里有一个方法 foo()，而 B、C 又都重写了 foo()，那 D 到底该继承哪一个版本？这就产生了 二义性。
第二，复杂性和可维护性。
多重继承会让类关系变得非常复杂，容易导致可读性和可维护性差。
所以 Java 的设计者选择只支持 单继承 + 多实现：
类只能继承一个父类；
但可以实现多个接口，这样既避免了多重继承的二义性，又能获得多态的灵活性。
从 JDK 8 开始，接口还能有 default 方法，进一步弥补了多重继承的不足，但依然避免了复杂的冲突

## 5.1 那为什么C++支持多重继承
**建议自己手动实践一下**
C++ 支持多重继承，是因为它更强调 灵活性和底层控制，同时提供了机制来解决多重继承带来的二义性。
第一，C++ 更贴近底层。它的设计目标之一是给开发者最大的自由度，包括直接操作内存、多继承、运算符重载等。这种灵活性带来强大功能，但同时也增加了复杂性。
第二，虚继承机制。
C++ 引入了 虚继承 (virtual inheritance) 来解决菱形继承问题。
举个例子，如果 B 和 C 都继承 A，D 同时继承 B 和 C，那么通过虚继承，D 里只会保留一份 A 的成员，从而避免二义性。
第三，适用场景。
在一些系统编程或底层库设计中，多重继承可以减少类层次结构的复杂度，避免过多的接口或模板组合。
但是相对来说，C++ 的多重继承写起来复杂，容易引发维护困难，所以在实际工程中也并不常用。很多 C++ 开发者也更倾向于 单继承 + 接口类（纯虚类） 的方式


# 以下其实并不基础，但是这些都是宏观特性，而Java实现了这些特性，


## 7.Java的序列化
序列化就是指将 Java 对象转换成二进制字节流的过程。

当我们需要对某些对象进行持久化时，需要先对它们序列化成二进制字节序列，然后存到数据库或者内存中。或者两个 Java 进程远程通信时，也需要将 Java 对象转换为字节序列才能在网络中传送。
首先被序列化的对象一定需要实现 Serializable 或 Externalizable 接口。
序列化与反序列化分别是通过 Java io 包下的 ObjectOutputStream 的 writeObject( ) 和 ObjectInputStream 的 readObject( ) 实现的。

## 8.Java的反射
反射就是在 Java 程序运行的过程中，动态获得某个类的方法变量，并调用的技术。

Spring 里面就大量用到了反射，比如通过 xml 文件获取 bean 的过程。具体来说，在配置 bean 时需要指定类的完全限定名，之后 Spring 就会从 xml 文件中读取到这个类名，并通过反射获取到对应的类，进而调用该类的构造函数创建实例对象。
除此之外，Java 的动态代理，序列化与反序列化中也用到了反射。在我的项目中为了实现对某些接口限频，先是对这些接口加上自定义的限频注解，然后在拦截器中利用反射，判断将要执行的接口是否含有限频的注解。

反射的优点就是能提高程序的灵活性和可扩展性，
比如刚说的通过 Spring 的 xml 文件来统一管理 bean 信息，同时也简化了某些功能的实现。
缺点主要是性能和安全问题。反射涉及了动态类型的解析，会有一定的性能开销，所以反射操作的效率要比那些非反射操作低。
其次，反射可以绕过访问修饰符的限制，对于私有成员也可以访问和修改，可能会导致安全问题。



## 9.Java的动态代理
我的理解是动态代理，实际上就是在不改变原有代码的情况下对原有的方法增强。



这样我们就可以在调用目标方法之前或之后，插入一些额外逻辑，比如日志、权限校验、事务管理等。

对于一些方法，他们可能需要一些统一的处理逻辑，例如打印日志，这时候我们就可以通过创建代理对象，来对原有方法进行功能上的加强。实现动态代理有两种方式，一种是通过jdk reflect包提供的proxy类实现，还有一种是通过cglib的enhancer实现。

对于jdk proxy它是面向接口的动态代理，也就是说只有一个类实现了接口，我们才能对它进行代理，本质上来说就是这个代理对象实现了被代理对象的接口，所以它只能增强接口中的方法，具体代码逻辑是通过重写invokationhandler的invoke方法，通过反射的方式对原有方法进行增强。

对于cglib的enhancer它是面向父类的动态代理，也就是说它代理一个对象就是通过继承被代理对象对原有方法增强，这就意味着它可以增强被代理对象的所有方法，并且由于反射机制的存在，可以获取到父类方法上的所有注解。

动态代理经常出现在框架中，例如mybatis通过面向接口的动态代理，对接口进行实现。在spring aop机制中，通过动态代理机制，对方法进行增强，aop中的前置通知，返回通知，异常通知等，都是通过在动态代理过程中，在相对原方法的不同位置执行对应逻辑而实现的。


## 10.Java的泛型是什么
泛型就是 在类、接口、方法中引入类型参数，让代码在编译期就能检查类型安全，同时复用相同的逻辑。

比如 List<String> 和 List<Integer>，逻辑是一样的，只是存储的类型不同。用泛型可以避免强制类型转换和运行时的 ClassCastException







